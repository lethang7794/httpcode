name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        go-version: [1.19, 1.20, 1.21]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ matrix.go-version }}

    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Download dependencies
      run: go mod download

    - name: Verify dependencies
      run: go mod verify

    - name: Run tests
      run: go test -v -race -coverprofile=coverage.out ./...

    - name: Generate coverage report
      run: go tool cover -html=coverage.out -o coverage.html

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella

    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v3
      with:
        version: latest

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.21

    - name: Build binary
      run: |
        go build -v -o httpcode .
        ./httpcode --help

  release:
    name: Release
    runs-on: ubuntu-latest
    needs: [test, build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: 1.21

    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Get latest tag
      id: get_tag
      run: |
        # Get the latest tag, default to v0.0.0 if no tags exist
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        echo "Latest tag: $LATEST_TAG"

    - name: Determine version bump
      id: version_bump
      run: |
        # Analyze commit messages since last tag to determine version bump
        LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
        
        # Get commits since last tag
        if [ "$LATEST_TAG" = "v0.0.0" ]; then
          COMMITS=$(git log --pretty=format:"%s" HEAD)
        else
          COMMITS=$(git log --pretty=format:"%s" ${LATEST_TAG}..HEAD)
        fi
        
        echo "Commits since last tag:"
        echo "$COMMITS"
        
        # Determine bump type based on conventional commits
        BUMP_TYPE="patch"
        
        if echo "$COMMITS" | grep -qE "^(feat|feature)(\(.+\))?!:|^.+!:|BREAKING CHANGE:"; then
          BUMP_TYPE="major"
        elif echo "$COMMITS" | grep -qE "^(feat|feature)(\(.+\))?:"; then
          BUMP_TYPE="minor"
        elif echo "$COMMITS" | grep -qE "^(fix|bugfix|perf|refactor)(\(.+\))?:"; then
          BUMP_TYPE="patch"
        fi
        
        echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
        echo "Determined bump type: $BUMP_TYPE"

    - name: Calculate new version
      id: new_version
      run: |
        LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
        BUMP_TYPE="${{ steps.version_bump.outputs.bump_type }}"
        
        # Remove 'v' prefix for calculation
        VERSION=${LATEST_TAG#v}
        
        # Split version into parts
        IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
        MAJOR=${VERSION_PARTS[0]:-0}
        MINOR=${VERSION_PARTS[1]:-0}
        PATCH=${VERSION_PARTS[2]:-0}
        
        # Bump version based on type
        case $BUMP_TYPE in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"

    - name: Check if version should be bumped
      id: should_release
      run: |
        LATEST_TAG="${{ steps.get_tag.outputs.latest_tag }}"
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        
        # Check if there are any commits since last tag
        if [ "$LATEST_TAG" = "v0.0.0" ]; then
          COMMIT_COUNT=$(git rev-list --count HEAD)
        else
          COMMIT_COUNT=$(git rev-list --count ${LATEST_TAG}..HEAD)
        fi
        
        if [ "$COMMIT_COUNT" -gt 0 ] && [ "$NEW_VERSION" != "$LATEST_TAG" ]; then
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "Should create release: true"
        else
          echo "should_release=false" >> $GITHUB_OUTPUT
          echo "Should create release: false"
        fi

    - name: Build release binaries
      if: steps.should_release.outputs.should_release == 'true'
      run: |
        mkdir -p dist
        
        # Build for multiple platforms
        GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o dist/httpcode-linux-amd64 .
        GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o dist/httpcode-linux-arm64 .
        GOOS=darwin GOARCH=amd64 go build -ldflags="-s -w" -o dist/httpcode-darwin-amd64 .
        GOOS=darwin GOARCH=arm64 go build -ldflags="-s -w" -o dist/httpcode-darwin-arm64 .
        GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o dist/httpcode-windows-amd64.exe .
        
        # Create checksums
        cd dist
        sha256sum * > checksums.txt
        cd ..

    - name: Create and push tag
      if: steps.should_release.outputs.should_release == 'true'
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        
        # Create annotated tag
        git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
        git push origin "$NEW_VERSION"
        
        echo "Created and pushed tag: $NEW_VERSION"

    - name: Create GitHub Release
      if: steps.should_release.outputs.should_release == 'true'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.new_version.outputs.new_version }}
        name: Release ${{ steps.new_version.outputs.new_version }}
        body: |
          ## Changes
          
          This release includes the following changes since the last version:
          
          ### Commits
          ```
          ${{ steps.version_bump.outputs.commits }}
          ```
          
          ## Installation
          
          ### Download Binary
          Download the appropriate binary for your platform from the assets below.
          
          ### Build from Source
          ```bash
          go install github.com/lethang7794/httpcode@${{ steps.new_version.outputs.new_version }}
          ```
          
          ### Verify Installation
          ```bash
          httpcode --help
          ```
        files: |
          dist/*
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
